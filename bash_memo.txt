環境変数「IFS」（Internal Filed Separator）には、bashの場合「スペース」「タブ」「改行」（$’ \t\n’）といった値が初期設定されていて、これらが文字の区切りとして認識されています。
ファイル等を読み込んだりする場合に、読み込む文の区切り文字を変更したい場合は、「IFS」に区切り文字としたい値を設定することで、区切りとさせる文字を好きに設定することが出来ます。

IFS_BACKUP=$IFS # バックアップしておく。
IFS=$'\n'  # 区切り文字を変更
# 任意の処理
IFS=$IFS_BACKUP # 元に戻す。

コマンドライン引数の文字列
#echo `cat ${1}`

#結局使わなかった．qiitaのシェルスクリプトの便利なやつとかいうサイトが有能だった
for ((初期値; ループ条件; ループ時の処理)); do
    # ...
done


配列の要素でループする
for i in "${array[@]}"
do
  ...
done
→for 文にダブルクォートで囲みインデックスに @ を指定した配列を渡す。
配列の全要素に対して処理を行いたい場合などで、配列の要素でループ処理を行いたい場合は、for 文のループ対象としてダブルクォートで囲みインデックスに @ を指定した配列を渡す。
注意点は以下の 2つ。
要素にスペースが含まれることを考慮してダブルクォートで囲むこと
* ではなく @ を使用すること
要素にスペースが入っていないことを保証できるのであれば、ダブルクォートを使用する必要もなく * と @ の使い分けも不要であるが、ベストプラクティスとして配列でループ処理を行う場合はダブルクォートと @ を使用すると覚えてほしい。
ちなみに、ダブルクォートと * を使用するとシェルが配列全体を一つの値として展開するので、要素が何個あろうともループが一回で終了してしまう。
$ # 「*」を使用してしまったダメな例
$ array=(1 2 3 4 5)
$ for i in "${array[*]}"
> do
>  echo "[${i}]"
> done
[1 2 3 4 5]
#↑要素が5個あるのに、ループが1回で終了している。
インデックスに * を指定した配列を for 文に渡すと、シェルは for i in "1 2 3 4 5" と解釈するため、意図したとおりのループにはならない。
$ # 「@」を使用した正しい例
$ array=(1 2 3 4 5)
$ for i in "${array[@]}"
> do
>  echo "[${i}]"
> done
[1]
[2]
[3]
[4]
[5]
#↑要素数分のループ処理が実行される。
インデックスに @ を指定することで、シェルは for i in "1" "2" "3" "4" "5" と解釈し、要素数分のループ処理を行うことができる。
また、ダブルクォートを使用しなければ、* と @ のどちらを使用しても結果は同じになるが、以下のように要素にスペースが含まれる場合に問題が発生する。
# 配列の要素がスペースを含んでいる場合 (ダブルクォート不使用)
$ array=(1 2 3 4 5 "6 6")
$ for i in ${array[*]}
> do
>   echo "[${i}]"
> done
[1]
[2]
[3]
[4]
[5]
[6]
[6]
#↑"6 6" がダブルクォートがないために 2つの要素と解釈されるためループ回数が 1回多くなっている。
$ for i in ${array[@]}
> do
>   echo "[${i}]"
> done
[1]
[2]
[3]
[4]
[5]
[6]
[6]
#↑"6 6" がダブルクォートがないために 2つの要素と解釈されるためループ回数が 1回多くなっている。
ダブルクォートを使用しなければ、シェルは for i in 1 2 3 4 5 6 6 と解釈する。そのため要素「6 6」を 2つの要素とみなされてしまう。
このような問題を避けるため、繰り返しになるが、ベストプラクティスとして配列でループ処理を行う場合はダブルクォートと @ を使用すること。
$ array=(1 2 3 4 5 "6 6")
$ for i in "${array[@]}"
> do
>   echo "[${i}]"
> done
[1]
[2]
[3]
[4]
[5]
[6 6]
#↑ダブルクォートと「@」を使用することでスペースを含む要素にも対応可能。



#簡単な例
mbp:searchsystem palcytion$ ./invert_index.sh aaa.txt bbb.txt
array1=(`cat $1|xargs`)
array2=(`cat $2|xargs`)
echo ${array1[@]}
echo ${array2[@]}
#天才
array1=(`cat $@|xargs`)
#空白を入れること．天才なのでmerge不要．
merged=(${array1[@]} ${array2[@]})
echo ${merged[@]}


#ダブルクオーテーションがあると反応しない．
#いいや，環境設定の問題だった．空白に反応するとオワル．いいえ，ダブルプラケットかどうかのせいでーす
if [ $(echo $text | grep -e 'h') ]; then
    echo "hoge include h"
else
    echo "hoge doesn't include h"
fi

#一応これで出力終わり．ただ汚い．-aは使えなかった．
for i in "${array[@]}"
do
  if [ $(cat $1 | grep -e $i) ] && [ $(cat $2 | grep -e $i) ]; then
      echo $i $1 $2
  elif [ $(cat $1 | grep -e $i) ]; then
    echo $i $1
  elif [ $(cat $2 | grep -e $i) ]; then
    echo $i $2
fi
done
#ダブルプラケットを使うほうが良い．環境変数に縛られない（語弊がある）grepが弱いのではない．
if [[ $(cat $1 | grep -e $i) && $(cat $2 | grep -e $i) ]]; then
    echo $i $1 $2
elif [[ $(cat $1 | grep -e $i) ]]; then
  echo $i $1
elif [[ $(cat $2 | grep -e $i) ]]; then
  echo $i $2
fi

#一般化する前
#配列をループで回す．ダブルコーテーションはつけておくべきだが，配列の中に空白がないので今回はいらない．
for i in ${array[@]}; do
  #コマンドライン引数でtxtファイルを引っ張ってくる．aaaとbbbがどちらも配列の要素に含まれている場合
  if [[ $(cat $1) =~ $i && $(cat $2) =~ $i ]]; then
    #出力
    echo $i $1 $2
  #aaaが含まれている場合
  elif [[ $(cat $1) =~ $i ]]; then
    echo $i $1
  #bbbが含まれている場合
  elif [[ $(cat $2) =~ $i ]]; then
    echo $i $2
  fi
done
